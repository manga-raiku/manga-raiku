drop trigger if exists "check_history_insert" on "public"."history";

drop policy "Disabled delete" on "public"."history";

drop policy "Enable insert for authenticated only user" on "public"."history";

drop policy "Enable read access for only user" on "public"."history";

drop policy "Enable update for only user" on "public"."history";

alter table "public"."history" drop constraint "history_user_id_fkey";

drop function if exists "public"."check_history_insert"();

alter table "public"."history" drop constraint "history_pkey";

drop index if exists "public"."history_pkey";

drop table "public"."history";

create table "public"."history_chapter" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "history_manga_id" bigint not null,
    "ep_id" bigint not null,
    "updated_at" timestamp with time zone not null default now()
);


alter table "public"."history_chapter" enable row level security;

create table "public"."history_manga" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "manga_name" text not null,
    "image" text not null,
    "manga_path" text not null,
    "manga_id" bigint not null,
    "user_id" uuid not null default auth.uid(),
    "last_ch_id" bigint not null,
    "last_ch_name" text not null,
    "last_ch_path" text not null,
    "updated_at" timestamp with time zone not null default now()
);


alter table "public"."history_manga" enable row level security;

CREATE INDEX follow_user_id_idx ON public.follow USING btree (user_id);

CREATE UNIQUE INDEX "history.chapter: history_manga_id + ep_id" ON public.history_chapter USING btree (history_manga_id, ep_id);

CREATE INDEX "history.chapter_history_manga_id_idx" ON public.history_chapter USING btree (history_manga_id);

CREATE UNIQUE INDEX "history.chapter_pkey" ON public.history_chapter USING btree (id);

CREATE UNIQUE INDEX "history.manga__manga_id_$_user_id_unique" ON public.history_manga USING btree (manga_id, user_id);

CREATE INDEX "history.manga_user_id_idx" ON public.history_manga USING btree (user_id);

CREATE UNIQUE INDEX history_pkey ON public.history_manga USING btree (id);

alter table "public"."history_chapter" add constraint "history.chapter_pkey" PRIMARY KEY using index "history.chapter_pkey";

alter table "public"."history_manga" add constraint "history_pkey" PRIMARY KEY using index "history_pkey";

alter table "public"."history_chapter" add constraint "history_chapter_history_manga_id_fkey" FOREIGN KEY (history_manga_id) REFERENCES history_manga(id) not valid;

alter table "public"."history_chapter" validate constraint "history_chapter_history_manga_id_fkey";

alter table "public"."history_manga" add constraint "history_manga_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) not valid;

alter table "public"."history_manga" validate constraint "history_manga_user_id_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public."handle_before_del_history.manga"()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$begin
  delete from history_chapter where history_manga_id = old.id;
  return old;
end;$function$
;

CREATE OR REPLACE FUNCTION public."history_manga@upsert::after"()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$begin
  if not exists(
    select 1 from history_chapter where history_manga_id = new.id and ep_id = new.last_ch_id
  ) then
    insert into history_chapter (history_manga_id, ep_id) values (new.id, new.last_ch_id);
  else
    update history_chapter set updated_at = now() where history_manga_id = new.id and ep_id = new.last_ch_id;
  end if;

  return new;
end;$function$
;

CREATE OR REPLACE FUNCTION public."history_manga@upsert::before"()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
begin
  -- if exists(select 1 from history_manga where user_id = auth.uid() and manga_id = new.manga_id limit 1) then
  --   update history_manga set
  --     manga_name   = new.manga_name,
  --     image        = new.image,
  --     manga_path   = new.manga_path,
      
  --     last_ch_id   = new.last_ch_id,
  --     last_ch_name = new.last_ch_name,
  --     last_ch_path = new.last_ch_path,
      
  --     updated_at   = now()
  --    where user_id = auth.uid() and manga_id = new.manga_id;
  --   return null;
  -- end if;

  NEW.updated_at := now();
  return new;
end;$function$
;

CREATE OR REPLACE FUNCTION public.handle_before_del_user()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$begin
  delete from history_manga where user_id = old.id;
  delete from follow where user_id = old.id;
  delete from profiles where id = old.id;
  return old;
end;$function$
;

create policy "Disable delete"
on "public"."history_chapter"
as permissive
for delete
to public
using (false);


create policy "Enable insert for authenticated users only"
on "public"."history_chapter"
as permissive
for insert
to authenticated
with check ((EXISTS ( SELECT 1
   FROM history_manga
  WHERE ((history_manga.id = history_chapter.history_manga_id) AND (history_manga.user_id = auth.uid()))
 LIMIT 1)));


create policy "Enable read access for only user"
on "public"."history_chapter"
as permissive
for select
to authenticated
using ((EXISTS ( SELECT 1
   FROM history_manga
  WHERE ((history_manga.id = history_chapter.history_manga_id) AND (history_manga.user_id = auth.uid()))
 LIMIT 1)));


create policy "Enable update for users based on email"
on "public"."history_chapter"
as permissive
for update
to authenticated
using ((EXISTS ( SELECT 1
   FROM history_manga
  WHERE ((history_manga.id = history_chapter.history_manga_id) AND (history_manga.user_id = auth.uid()))
 LIMIT 1)))
with check ((EXISTS ( SELECT 1
   FROM history_manga
  WHERE ((history_manga.id = history_chapter.history_manga_id) AND (history_manga.user_id = auth.uid()))
 LIMIT 1)));


create policy "Disabled delete"
on "public"."history_manga"
as permissive
for delete
to public
using (false);


create policy "Enable insert for authenticated only user"
on "public"."history_manga"
as permissive
for insert
to authenticated
with check (((user_id = auth.uid()) AND (created_at = now())));


create policy "Enable read access for only user"
on "public"."history_manga"
as permissive
for select
to authenticated
using ((user_id = auth.uid()));


create policy "Enable update for only user"
on "public"."history_manga"
as permissive
for update
to authenticated
using ((user_id = auth.uid()))
with check (((user_id = auth.uid()) AND (created_at IS NULL) AND (updated_at IS NULL)));


create policy "Disable delete"
on "public"."profiles"
as permissive
for delete
to public
using (false);


CREATE TRIGGER "history_manga@upsert::after" AFTER INSERT OR UPDATE ON public.history_manga FOR EACH ROW EXECUTE FUNCTION "history_manga@upsert::after"();

CREATE TRIGGER "on_before_del_history.manga" BEFORE DELETE ON public.history_manga FOR EACH ROW EXECUTE FUNCTION "handle_before_del_history.manga"();

CREATE TRIGGER "on_history_manga@upsert::before" BEFORE INSERT OR UPDATE ON public.history_manga FOR EACH ROW EXECUTE FUNCTION "history_manga@upsert::before"();


